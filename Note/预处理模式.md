题目来源hdu 6107 Typesetting的两种预处理方法

## 两种预处理模式的对比

### 模式1：自身先加入（f1模式）
```cpp
for (int i = 1; i <= n; i++) {
    int cnt = character[i], j = i + 1;  // 自身先加入
    while (cnt + character[j] + 1 <= w && j <= n)
        cnt += character[j++] + 1;
    f1[i][0] = j - i;  // 至少为1
}
```

### 模式2：自身不先加入（f2模式）
```cpp
for (int i = 1; i <= n; i++) {
    int cnt = 0, j = i, flag = 0;  // cnt从0开始
    while (cnt + character[j] + flag <= dw && j <= n)
        cnt += character[j++] + flag, flag = 1;
    // 继续处理...
    f2[i][0] = j - i;  // 可能为0
}
```

## 核心区别

| 特征        | 模式1 (自身先加入) | 模式2 (自身不先加入) |
| ----------- | ------------------ | -------------------- |
| **初始cnt** | `character[i]`     | `0`                  |
| **起始j**   | `i + 1`            | `i`                  |
| **最小值**  | 至少为1            | 可能为0              |
| **语义**    | "从i开始必须放"    | "从i开始尝试放"      |

## 适用场景

### 模式1适用场景：
1. **必须包含当前元素**的情况
2. **贪心算法的起始点**
3. **每个位置必须有输出的场景**
4. **普通文本行**（每行必须至少有一个单词）

**典型应用：**
- 文本排版（普通行）
- 区间覆盖问题
- 任务调度（必须从某个任务开始）

### 模式2适用场景：
1. **可选包含当前元素**的情况
2. **容量限制严格**的场景
3. **可能无法放置任何元素**的情况
4. **带约束的放置问题**

**典型应用：**
- 图片行文本放置
- 背包问题的容量检查
- 资源分配（可能无法分配）
- 有前置条件的场景

## 在算法竞赛中的出现频率

### 高频出现：
1. **滑动窗口/双指针**：多用模式1
2. **区间覆盖**：多用模式1  
3. **容量限制问题**：两种都可能用到
4. **预处理+稀疏表**：两种都很常见

### 选择原则：

**用模式1当：**
- 当前元素必须被处理
- 结果必须有意义（不能为0）
- 作为后续计算的可靠基础

**用模式2当：**
- 当前元素可能无法被容纳
- 需要严格的容量检查
- 结果可能表示"无法处理"

## 实际例子对比

### 例子1：普通文本行（模式1）
```cpp
// 每行必须至少放一个单词
cnt = a[i];  // 当前单词必须放
j = i + 1;   // 从下一个开始尝试
```

### 例子2：图片旁文本（模式2）
```cpp
// 可能一个单词都放不下
cnt = 0;     // 从空开始
j = i;       // 从当前单词开始尝试
if (a[i] > dw) {
    // 连第一个单词都放不下
    f2[i][0] = 0;
}
```

## 总结建议

1. **理解问题语义**：当前元素是必须包含还是可选包含？
2. **检查边界条件**：结果能否为0？最小值的含义是什么？
3. **考虑后续使用**：稀疏表递推时是否需要处理0值？
4. **保持一致**：在同一个问题中，相似的子问题使用相同的模式

这两种模式在算法竞赛中确实很常见，理解它们的区别和适用场景对于正确解决问题非常重要。关键是要根据问题的**物理意义**和**约束条件**来选择适当的模式。

## 抽象模型

### 模式1：强制包含模式 (Mandatory Inclusion)
```python
def pattern1(start_index):
    # 强制包含起始元素
    current_value = value(start_index)
    next_index = start_index + 1
    
    while can_include(next_index, current_value):
        current_value = combine(current_value, value(next_index))
        next_index += 1
    
    return next_index - start_index  # 至少为1
```

### 模式2：可选包含模式 (Optional Inclusion)
```python
def pattern2(start_index):
    # 可选包含起始元素
    current_value = initial_value
    current_index = start_index
    
    while can_include(current_index, current_value):
        current_value = combine(current_value, value(current_index))
        current_index += 1
    
    return current_index - start_index  # 可能为0
```

## 核心决策框架

### 什么时候用模式1？
当问题满足以下**任意一条**时：

1. **起始点约束**：必须从当前位置开始处理
2. **完整性要求**：每个分段必须包含至少一个元素
3. **语义约束**：空结果没有意义
4. **贪心基础**：需要确保每个位置都有有效结果

### 什么时候用模式2？
当问题满足以下**任意一条**时：

1. **容量约束**：当前位置可能无法被容纳
2. **条件包含**：元素是否被包含取决于某些条件
3. **零结果有效**：空结果是有意义的业务状态
4. **严格限制**：有严格的资源/容量限制

## 通用决策树

```
问题 → 当前元素是否必须被包含？
    ├── 是 → 模式1 (强制包含)
    │   ├── 文本行必须包含至少一个单词
    │   ├── 任务调度必须从某个任务开始
    │   └── 区间覆盖必须包含起始点
    │
    └── 否 → 模式2 (可选包含)
        ├── 容量限制可能排除当前元素
        ├── 条件检查可能跳过当前元素
        └── 空结果是有效状态
```

## 扩展到其他算法场景

### 1. 动态规划
```cpp
// 模式1：必须使用当前元素
dp[i] = max(dp[i], value[i] + dp[i-1]);

// 模式2：可选使用当前元素  
dp[i] = max(dp[i-1], value[i] + dp[i-2]);
```

### 2. 图遍历
```cpp
// 模式1：必须从当前节点扩展
for (auto neighbor : graph[current]) {
    if (!visited[neighbor]) {
        dfs(neighbor);
    }
}

// 模式2：可选从当前节点扩展
if (should_expand(current)) {
    for (auto neighbor : graph[current]) {
        if (meets_condition(neighbor)) {
            dfs(neighbor);
        }
    }
}
```

### 3. 资源分配
```cpp
// 模式1：必须分配资源给当前任务
allocate(current_task, min_resources);

// 模式2：可选分配资源给当前任务
if (has_enough_resources(current_task)) {
    allocate(current_task, requested_resources);
}
```

## 实用检查清单

### 选择模式1如果：
- [ ] 每个位置必须有输出
- [ ] 结果序列不能有间隙
- [ ] 空集合不是有效解
- [ ] 需要建立完整的覆盖

### 选择模式2如果：
- [ ] 可能无法处理当前元素
- [ ] 有严格的准入条件
- [ ] 零结果是有效状态
- [ ] 需要容量/资源检查

## 在竞赛中的应用模式

### 常见模式1场景：
- **文本排版**：每行必须至少一个单词
- **区间合并**：必须包含当前区间
- **路径遍历**：必须访问当前节点
- **序列分割**：每个段必须非空

### 常见模式2场景：
- **容量受限放置**：可能无法放置当前物品
- **条件选择**：可能跳过当前元素
- **资源分配**：可能无法分配资源
- **准入控制**：可能拒绝当前请求

## 总结

这两种模式本质上是**包含策略**的选择：

- **模式1**："我必须从这里开始，能带多少带多少"
- **模式2**："我尝试从这里开始，但可能一个都带不走"

**决策关键**：问自己"如果当前元素不符合条件，我还能继续吗？"
- 如果不能 → 模式1
- 如果能 → 模式2

这种思维方式可以应用到各种算法问题中，帮助你快速选择正确的预处理策略。