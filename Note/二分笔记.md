# 二分上下取整
这是一个很好的问题！二分查找中取整方式的选择很重要，我来详细解释：

## 核心原则

**取整方式取决于收缩边界的方式**：

### 情况1：`mid = (l + r) >> 1` （下取整）
当条件满足时 **`l = mid + 1`**，不满足时 **`r = mid`**

```cpp
while (l < r) {
    mid = (l + r) >> 1;        // 下取整
    if (check(mid))
        l = mid + 1;           // 向右收缩
    else
        r = mid;               // 向左收缩
}
// 结束时 l == r
```

### 情况2：`mid = (l + r + 1) >> 1` （上取整）
当条件满足时 **`l = mid`**，不满足时 **`r = mid - 1`**

```cpp
while (l < r) {
    mid = (l + r + 1) >> 1;    // 上取整
    if (check(mid))
        l = mid;               // 向右收缩
    else
        r = mid - 1;           // 向左收缩
}
// 结束时 l == r
```

## 记忆口诀

**"加一就加一，不加就不加"**：
- 如果 `l = mid`，那么 `mid` 计算要 **加1**（上取整）
- 如果 `l = mid + 1`，那么 `mid` 计算 **不加1**（下取整）

**"上变上舍，下变下舍"**

## 在你的代码中的应用

你的代码：
```cpp
if (min_blood <= b && min_blood != -1)
    l = mid;      // 这里用 l = mid
else
    r = mid - 1;  // 这里用 r = mid - 1
```

根据规则，因为 `l = mid`，所以应该：
```cpp
mid = (l + r + 1) >> 1;  // 上取整
```

## 具体例子说明

假设 `l = 3, r = 4`：

### 下取整（错误）：
```cpp
mid = (3 + 4) >> 1 = 3;
if (条件满足)
    l = mid;  // l = 3
// 死循环：l=3, r=4 → mid=3 → l=3 → 无限循环
```

### 上取整（正确）：
```cpp
mid = (3 + 4 + 1) >> 1 = 4;
if (条件满足)
    l = mid;  // l = 4
// 结束：l=4, r=4 → 退出循环
```

## 实际应用模板

### 模板1：找第一个满足条件的
```cpp
while (l < r) {
    int mid = (l + r) >> 1;      // 下取整
    if (check(mid))
        r = mid;                 // 向左找更小的
    else
        l = mid + 1;             // 向右找
}
```

### 模板2：找最后一个满足条件的（你的情况）
```cpp
while (l < r) {
    int mid = (l + r + 1) >> 1;  // 上取整
    if (check(mid))
        l = mid;                 // 向右找更大的  
    else
        r = mid - 1;             // 向左找
}
```

在你的代码中，你想要找**最后一个**费用值满足条件的解，所以应该用模板2（上取整）。

## 总结

- **`l = mid` → `mid = (l + r + 1) >> 1`**（上取整）
- **`l = mid + 1` → `mid = (l + r) >> 1`**（下取整）

记住这个对应关系就不会错了！