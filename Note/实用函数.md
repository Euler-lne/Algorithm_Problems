# 快速幂
快速幂确实是一个经典的算法，初学者可能会觉得它有点绕。不过别担心，掌握了它的原理和几个关键点之后，你会发现它其实很有规律，记忆起来也不难。下面我帮你梳理几个记忆技巧，希望能帮你轻松记住它。

---

### 1. 理解核心思想：指数的二进制分解

假设我们要计算 \(a^{13}\)。13 的二进制是 `1101`，也就是：
\[
13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0
\]
那么：
\[
a^{13} = a^{8} \times a^{4} \times a^{1}
\]
注意，这些指数 \(8,4,1\) 恰好对应二进制位为 1 的那些位。而 \(a^{8}\) 可以由 \(a^{4}\) 平方得到，\(a^{4}\) 可以由 \(a^{2}\) 平方得到，依此类推。

**关键点**：我们只需要从底数 \(a\) 开始，不断自乘（平方），就可以得到 \(a^{2^0}, a^{2^1}, a^{2^2}, \dots\) 这些值。然后在指数二进制位为 1 的位置，把对应的值乘到结果里。

---

### 2. 代码结构三要素

快速幂的代码非常固定，可以概括为 **“一个循环，两个操作，一个判断”**：

- **一个循环**：`while (p)` —— 只要指数不为 0，就继续处理。
- **两个操作**：
  1. **底数平方**：`base = base * base % mod` —— 每轮循环都执行，相当于从 \(a^{2^0}\) 到 \(a^{2^1}\)，再到 \(a^{2^2}\)……不断翻倍。
  2. **指数右移**：`p >>= 1` —— 每轮循环末尾执行，去掉已经处理过的最低位。
- **一个判断**：`if (p & 1)` —— 检查当前指数的最低位是否为 1（是否为奇数）。如果是，就把当前的 `base` 乘到结果 `ans` 中。

---

### 3. 记忆口诀

你可以用一句顺口溜来记住这个流程：

> **“指数不为零，循环继续行；低位若有 1，结果乘 base；base 平方再赋值，指数右移莫忘记。”**

或者更简短的：

> **“有 1 乘底，底数平方，指数右移”**

配合例子理解：
- 初始：`ans = 1`, `base = a`, `p = 13`（二进制 1101）
- 第 1 轮：`p` 最低位为 1 → `ans *= base`（乘 \(a^1\)），然后 `base` 平方（变成 \(a^2\)），`p` 右移（变成 6，二进制 110）
- 第 2 轮：`p` 最低位为 0 → 不乘，`base` 平方（变成 \(a^4\)），`p` 右移（变成 3，二进制 11）
- 第 3 轮：`p` 最低位为 1 → `ans *= base`（乘 \(a^4\)），`base` 平方（变成 \(a^8\)），`p` 右移（变成 1）
- 第 4 轮：`p` 最低位为 1 → `ans *= base`（乘 \(a^8\)），`base` 平方（\(a^{16}\)），`p` 右移（变成 0）
- 结束，`ans = a^1 * a^4 * a^8 = a^{13}`

---

### 4. 与普通乘法对比记忆

普通的乘法是直接循环 `p` 次累乘：
```cpp
for (int i = 0; i < p; ++i) ans = ans * a % mod;
```
快速幂相当于把指数 `p` 的二进制位“拆开”来乘，利用了平方快速得到高位次幂，从而把 O(p) 降为 O(log p)。你可以想象成：“我一次翻倍底数，相当于一次跳过多位，只有当二进制位是 1 时才停下来乘一下。”

---

### 5. 特殊情况提醒

- 指数 `p` 为 0 时，循环不执行，直接返回 `ans = 1`，这是正确的（任何数的 0 次幂为 1）。
- 模数 `mod` 只在乘法后取模，保持数值在范围内。
- 如果底数 `a` 可能很大，可以用 `long long` 防止乘法溢出（或先取模）。

---

### 6. 手写几遍，加深肌肉记忆

算法光看不行，动手写几遍效果最好。你可以尝试：
- 自己默写一遍代码，然后对照检查。
- 用不同的指数（如 5, 10, 16）手动模拟循环过程，看结果是否正确。
- 或者用一个小数值（比如 a=2, p=5, mod=100）实际运行一下，观察中间变量的变化。

多练习几次，你就会发现它其实很自然。

---

### 7. 代码模板（方便背诵）

```cpp
/**
 * 快速幂取模运算
 * @param a 底数
 * @param p 指数（非负整数）
 * @return a^p % MOD_NUM 的值
 *
 * 原理：将指数p按二进制分解，通过平方和乘法累积结果，
 *       每轮迭代处理一个二进制位，时间复杂度O(log p)
 */
long long qpow(int a, int p)
{
    long long ans = 1;
    long long base = a; // 当前底数，初始为 a
    while (p) {
        if (p & 1)                      // 如果当前最低位为 1 奇数
            ans = ans * base % MOD_NUM; // 乘入当前底数并取模
        base = base * base % MOD_NUM;   // 底数平方
        p = p >> 1;                     // 右移一位
    }
    return ans;
}

```