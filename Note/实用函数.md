# 快速幂
快速幂确实是一个经典的算法，初学者可能会觉得它有点绕。不过别担心，掌握了它的原理和几个关键点之后，你会发现它其实很有规律，记忆起来也不难。下面我帮你梳理几个记忆技巧，希望能帮你轻松记住它。

---

### 1. 理解核心思想：指数的二进制分解

假设我们要计算 \(a^{13}\)。13 的二进制是 `1101`，也就是：
\[
13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0
\]
那么：
\[
a^{13} = a^{8} \times a^{4} \times a^{1}
\]
注意，这些指数 \(8,4,1\) 恰好对应二进制位为 1 的那些位。而 \(a^{8}\) 可以由 \(a^{4}\) 平方得到，\(a^{4}\) 可以由 \(a^{2}\) 平方得到，依此类推。

**关键点**：我们只需要从底数 \(a\) 开始，不断自乘（平方），就可以得到 \(a^{2^0}, a^{2^1}, a^{2^2}, \dots\) 这些值。然后在指数二进制位为 1 的位置，把对应的值乘到结果里。

---

### 2. 代码结构三要素

快速幂的代码非常固定，可以概括为 **“一个循环，两个操作，一个判断”**：

- **一个循环**：`while (p)` —— 只要指数不为 0，就继续处理。
- **两个操作**：
  1. **底数平方**：`base = base * base % mod` —— 每轮循环都执行，相当于从 \(a^{2^0}\) 到 \(a^{2^1}\)，再到 \(a^{2^2}\)……不断翻倍。
  2. **指数右移**：`p >>= 1` —— 每轮循环末尾执行，去掉已经处理过的最低位。
- **一个判断**：`if (p & 1)` —— 检查当前指数的最低位是否为 1（是否为奇数）。如果是，就把当前的 `base` 乘到结果 `ans` 中。

---

### 3. 记忆口诀

你可以用一句顺口溜来记住这个流程：

> **“指数不为零，循环继续行；低位若有 1，结果乘 base；base 平方再赋值，指数右移莫忘记。”**

或者更简短的：

> **“有 1 乘底，底数平方，指数右移”**

配合例子理解：
- 初始：`ans = 1`, `base = a`, `p = 13`（二进制 1101）
- 第 1 轮：`p` 最低位为 1 → `ans *= base`（乘 \(a^1\)），然后 `base` 平方（变成 \(a^2\)），`p` 右移（变成 6，二进制 110）
- 第 2 轮：`p` 最低位为 0 → 不乘，`base` 平方（变成 \(a^4\)），`p` 右移（变成 3，二进制 11）
- 第 3 轮：`p` 最低位为 1 → `ans *= base`（乘 \(a^4\)），`base` 平方（变成 \(a^8\)），`p` 右移（变成 1）
- 第 4 轮：`p` 最低位为 1 → `ans *= base`（乘 \(a^8\)），`base` 平方（\(a^{16}\)），`p` 右移（变成 0）
- 结束，`ans = a^1 * a^4 * a^8 = a^{13}`

---

### 4. 与普通乘法对比记忆

普通的乘法是直接循环 `p` 次累乘：
```cpp
for (int i = 0; i < p; ++i) ans = ans * a % mod;
```
快速幂相当于把指数 `p` 的二进制位“拆开”来乘，利用了平方快速得到高位次幂，从而把 O(p) 降为 O(log p)。你可以想象成：“我一次翻倍底数，相当于一次跳过多位，只有当二进制位是 1 时才停下来乘一下。”

---

### 5. 特殊情况提醒

- 指数 `p` 为 0 时，循环不执行，直接返回 `ans = 1`，这是正确的（任何数的 0 次幂为 1）。
- 模数 `mod` 只在乘法后取模，保持数值在范围内。
- 如果底数 `a` 可能很大，可以用 `long long` 防止乘法溢出（或先取模）。

---

### 6. 手写几遍，加深肌肉记忆

算法光看不行，动手写几遍效果最好。你可以尝试：
- 自己默写一遍代码，然后对照检查。
- 用不同的指数（如 5, 10, 16）手动模拟循环过程，看结果是否正确。
- 或者用一个小数值（比如 a=2, p=5, mod=100）实际运行一下，观察中间变量的变化。

多练习几次，你就会发现它其实很自然。

---

### 7. 代码模板（方便背诵）

```cpp
/**
 * 快速幂取模运算
 * @param a 底数
 * @param p 指数（非负整数）
 * @return a^p % MOD_NUM 的值
 *
 * 原理：将指数p按二进制分解，通过平方和乘法累积结果，
 *       每轮迭代处理一个二进制位，时间复杂度O(log p)
 */
long long qpow(int a, int p)
{
    long long ans = 1;
    long long base = a; // 当前底数，初始为 a
    while (p) {
        if (p & 1)                      // 如果当前最低位为 1 奇数
            ans = ans * base % MOD_NUM; // 乘入当前底数并取模
        base = base * base % MOD_NUM;   // 底数平方
        p = p >> 1;                     // 右移一位
    }
    return ans;
}

```

# 数组原地去重函数 sort_ 笔记

`sort_` 函数的作用是对已排序的向量进行原地去重，并返回去重后的有效长度。它类似于标准库的 `std::unique`，但更简洁易懂。下面我们从原理、代码结构、记忆技巧到示例，帮你彻底掌握它。

---

## 1. 核心思想：双指针法（快慢指针）

假设我们有一个**已排序**的数组，重复的元素必然相邻。去重的目标就是保留每个元素的一个副本，并将它们移到数组前端，同时忽略后续的重复项。

**关键点**：我们维护两个指针（或索引）：
- **慢指针** `size`：指向当前已去重部分的末尾（即下一个要存放不重复元素的位置）。初始为 1，因为第一个元素肯定保留。
- **快指针** `i`：遍历整个数组，从第二个元素开始。它负责寻找与上一个保留元素不同的新元素。

每遇到一个新元素（即 `nums[i] != nums[size-1]`），就把它复制到 `size` 位置，然后 `size` 向前移动一位。这样，`[0, size-1]` 区间内就是去重后的结果，而 `[size, n-1]` 保留的是无效的重复数据（可以忽略）。

---

## 2. 代码结构三要素

这个函数的代码非常固定，可以概括为 **“一次排序，一次遍历，一个条件，一个移动”**：

- **一次排序**：`sort(nums.begin(), nums.end())` —— 确保重复元素相邻，这是去重的前提。
- **一次遍历**：`for (int i = 1; i < nums.size(); i++)` —— 从第二个元素开始扫描。
- **一个条件**：`if (nums[i] != nums[size - 1])` —— 判断当前元素是否与上一个保留元素不同。
- **一个移动**：`nums[size++] = nums[i]` —— 如果不同，就将其复制到慢指针位置，并递增慢指针。

最后返回 `size`，即去重后的元素个数。

---

## 3. 记忆口诀

你可以用一句顺口溜来记住这个流程：

> **“排序之后去重易，快慢指针记心里；慢指 size 初为一，快指 i 从 1 开始；遇到不同就复制，size 前移不迟疑。”**

或者更精简：

> **“排序 + 双指针，不同就覆盖，size 即新长。”**

配合例子理解：
- 初始：`nums = [5,2,2,3,3,3,1]`，先排序得 `[1,2,2,3,3,3,5]`。
- `size = 1`，指向第二个位置（索引 1），`i = 1`。
  - `i=1`：`nums[1]=2`，`nums[size-1]=nums[0]=1`，不同 → 复制 `nums[1]` 到 `nums[1]`（本身），`size` 变为 2。
  - `i=2`：`nums[2]=2`，`nums[size-1]=nums[1]=2`，相同 → 不复制。
  - `i=3`：`nums[3]=3`，`nums[size-1]=nums[1]=2`，不同 → 复制到 `nums[2]`，`size=3`。
  - `i=4`：`nums[4]=3`，`nums[size-1]=nums[2]=3`，相同 → 不复制。
  - `i=5`：`nums[5]=3`，`nums[size-1]=nums[2]=3`，相同 → 不复制。
  - `i=6`：`nums[6]=5`，`nums[size-1]=nums[2]=3`，不同 → 复制到 `nums[3]`，`size=4`。
- 循环结束，`size=4`，数组前 4 个元素变为 `[1,2,3,5]`，后面元素（`[3,3,5]`）无用。

---

## 4. 与标准库 `std::unique` 对比

`std::unique` 的作用与此完全相同，返回一个指向新逻辑结尾的迭代器。但手动实现有助于理解底层原理：

- `std::unique` 内部也是双指针，用法：`auto last = std::unique(nums.begin(), nums.end()); nums.erase(last, nums.end());`
- 我们这里的 `sort_` 返回长度，但**不会改变 vector 的 `size()`**，需要调用者手动 `resize(size)` 才能截断。这是与 `std::unique` 的主要区别。

---

## 5. 注意事项

- **前提条件**：数组必须已排序，否则去重无效（重复元素可能不相邻）。所以我们先调用 `sort`。
- **原地修改**：函数直接修改原数组，前 `size` 个位置是去重结果，后续元素保持原值但逻辑上无效。
- **返回值**：返回新长度，调用后通常应执行 `nums.resize(size)` 以释放多余空间，或仅使用前 `size` 个元素。
- **边界情况**：
  - 空数组：`size` 初始为 1，但 `nums.size()` 为 0，循环不会执行，返回 1 显然错误。需处理空数组情况。但题目中 `n<<1` 至少为 2，所以暂时安全。若通用，应加判断：
    ```cpp
    if (nums.empty()) return 0;
    ```
  - 数组只有一个元素：循环不执行，返回 1，正确。
- **类型无关**：此方法适用于任意可比较类型，只需修改 `vector` 的类型。

---

## 6. 手写几遍，加深肌肉记忆

你可以尝试：
- 在纸上模拟 `[1,1,2,3,3,4]` 的去重过程。
- 自己默写代码，注意 `size` 的初值和循环边界。
- 对比 `std::unique` 的用法，加深理解。

多练习几次，你会发现它其实很自然。

---

## 7. 代码模板（方便背诵）

```cpp
/**
 * 原地去重已排序的向量，返回新长度
 * @param nums 已排序的向量（会被修改）
 * @return 去重后的有效元素个数
 *
 * 原理：双指针法，慢指针指向下一个存放位置，快指针扫描整个数组。
 *       每遇到新元素，就复制到慢指针处，慢指针前进。
 */
int sort_(vector<long long>& nums) {
    if (nums.empty()) return 0;               // 处理空数组
    sort(nums.begin(), nums.end());            // 先排序（若已排序可省略）
    int size = 1;                               // 第一个元素保留
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] != nums[size - 1]) {        // 发现新元素
            nums[size++] = nums[i];             // 复制并移动慢指针
        }
    }
    return size;
}
```

调用后通常需要：
```cpp
int newLen = sort_(vec);
vec.resize(newLen);   // 真正截断向量
```

---

通过以上笔记，你应该能轻松掌握这个去重函数的核心思想和实现细节。它和快速幂一样，都是经典且固定的模式，记住口诀和步骤，多写几次就能熟练运用。