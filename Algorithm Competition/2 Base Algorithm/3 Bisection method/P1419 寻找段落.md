# P1419 寻找段落

## 题目描述

给定一个长度为 $n$ 的序列 $a$，定义 $a_i$ 为第 $i$ 个元素的价值。现在需要找出序列中最有价值的“段落”。段落的定义是长度在 $[S, T]$ 之间的连续序列。最有价值段落是指平均值最大的段落。

**段落的平均值** 等于 **段落总价值** 除以 **段落长度**。

## 输入格式

第一行一个整数 $n$，表示序列长度。

第二行两个整数 $S$ 和 $T$，表示段落长度的范围，在 $[S, T]$ 之间。

第三行到第 $n+2$ 行，每行一个整数表示每个元素的价值指数。

## 输出格式

一个实数，保留 $3$ 位小数，表示最优段落的平均值。

## 输入输出样例 #1

### 输入 #1

```
3
2 2
3
-1
2
```

### 输出 #1

```
1.000
```

## 说明/提示

【数据范围】

对于 $30\%$ 的数据有 $n \le 1000$。

对于 $100\%$ 的数据有 $1 \le n \le 100000$，$1 \le S \le T \le n$，$-{10}^4 \le a_i \le {10}^4$。

【题目来源】

tinylic 改编


# 笔记

## 为什么这道题需要用单调递增队列？

这道题的核心是**在长度限制 [S, T] 内找到平均值最大的连续子数组**。使用单调递增队列是为了**高效解决**这个问题，而不是唯一方法。

## 问题分析

### 直接暴力方法的局限性
最直接的方法是枚举所有可能的子数组：
```cpp
double max_avg = -1e9;
for (int i = 0; i < n; i++) {
    for (int j = i+S-1; j <= min(n-1, i+T-1); j++) {
        double sum = 0;
        for (int k = i; k <= j; k++) {
            sum += a[k];
        }
        max_avg = max(max_avg, sum / (j-i+1));
    }
}
```
时间复杂度：O(n × (T-S) × 平均长度) ≈ O(n³)，对于 n=100000 完全不可行。

### 优化思路

#### 第一步：前缀和优化
使用前缀和数组可以快速计算任意子数组的和：
```cpp
vector<double> prefix(n+1, 0);
for (int i = 1; i <= n; i++) {
    prefix[i] = prefix[i-1] + a[i-1];
}
// 子数组 a[i...j] 的和 = prefix[j+1] - prefix[i]
```
时间复杂度降到 O(n²)，但对于 n=100000 仍然不够。

#### 第二步：二分答案 + 数学转化
关键观察：如果我们猜测一个平均值 `mid`，那么：
```
(a[i] + a[i+1] + ... + a[j]) / (j-i+1) >= mid
⇔ (a[i]-mid) + (a[i+1]-mid) + ... + (a[j]-mid) >= 0
```

定义新数组：`b[k] = a[k] - mid`
定义前缀和：`sum[k] = b[1] + b[2] + ... + b[k]`

问题转化为：**是否存在长度在 [S, T] 之间的子数组，其对应的 `b` 数组的和 ≥ 0**。

即：是否存在 `i, j` 满足 `S ≤ j-i ≤ T` 且 `sum[j] - sum[i] ≥ 0`。

#### 第三步：单调队列优化

对于固定的右端点 `j`，我们需要在 `[j-T, j-S]` 范围内找到**最小的** `sum[i]`。

为什么找最小的？
- 因为 `sum[j] - sum[i] ≥ 0` ⇔ `sum[j] ≥ sum[i]`
- 对于固定的 `sum[j]`，`sum[i]` 越小越容易满足条件

**这就是需要单调递增队列的原因！**

## 单调递增队列的工作原理

### 队列设计
维护一个双端队列，其中存储的是下标，且这些下标对应的 `sum` 值是**单调递增**的。

```cpp
deque<int> q;  // 存储下标，q.front() 对应最小的 sum 值
```

### 为什么单调递增？

对于每个右端点 `j`：
1. 我们想要在 `[j-T, j-S]` 范围内找到最小的 `sum[i]`
2. 如果队列是单调递增的，那么**队首元素**就是当前窗口中的最小值
3. 我们只需要检查 `sum[j] - sum[q.front()] ≥ 0`

### 具体操作

```cpp
for (int j = 1; j <= n; j++) {
    // 1. 将新的候选左端点加入队列
    if (j >= S) {
        int candidate = j - S;  // 对应长度 S 的子数组
        // 维护单调性：从队尾移除比当前候选"差"的元素
        while (!q.empty() && sum[q.back()] > sum[candidate]) {
            q.pop_back();
        }
        q.push_back(candidate);
    }
    
    // 2. 移除超出范围的左端点
    while (!q.empty() && q.front() < j - T) {
        q.pop_front();
    }
    
    // 3. 检查是否存在满足条件的子数组
    if (!q.empty() && sum[j] - sum[q.front()] >= 0) {
        return true;  // 存在平均值 ≥ mid 的段落
    }
}
```

## 完整算法流程

1. **二分答案**：在 `[min_val, max_val]` 范围内二分猜测最大平均值 `mid`
2. **构造新数组**：`b[i] = a[i] - mid`
3. **计算前缀和**：`sum[i] = b[1] + ... + b[i]`
4. **单调队列检查**：使用上述方法检查是否存在满足条件的子数组
5. **调整二分边界**：根据检查结果调整搜索范围

## 时间复杂度分析

- **二分**：O(log(20000/ε))，其中 ε=1e-5，约 20 次
- **每次检查**：O(n) - 每个元素入队出队各一次
- **总复杂度**：O(n log(20000/ε))，对于 n=100000 完全可行

## 如果不使用单调队列会怎样？

如果使用朴素方法找最小值：
```cpp
for (int j = 1; j <= n; j++) {
    double min_sum = 1e18;
    for (int i = max(0, j-T); i <= j-S; i++) {
        min_sum = min(min_sum, sum[i]);
    }
    if (sum[j] - min_sum >= 0) return true;
}
```
时间复杂度：O(n × (T-S))，最坏情况下 O(n²)，仍然可能超时。

## 总结

使用**单调递增队列**是因为：

1. **效率要求**：n=100000 需要 O(n) 或 O(n log n) 算法
2. **问题特性**：需要在滑动窗口中快速找到最小值
3. **数学转化**：将平均值比较转化为前缀和比较，进而转化为寻找最小值问题
4. **单调队列优势**：O(1) 时间获取当前窗口最小值

单调队列是这个问题的**最优解**，它巧妙地将 O(n²) 的问题降到了 O(n)，使得大数据规模下的计算成为可能。