# 🐮 找7的倍数 —— 从超时到高效的优化笔记

## 📖 问题回顾
Farmer John 的 N 头奶牛站成一排，每头奶牛有一个整数 ID。他想找一段**连续**的奶牛，使得它们的 ID 之和是 **7 的倍数**。问：这样的连续段最长可以有多长？如果不存在，输出 0。

N 最多可达 50000，ID 范围 0～1,000,000。

---

## 🐢 超时版本 —— 你的原始代码

```cpp
#include <iostream>
using namespace std;

int const MAX_N = 5 * 1e4 + 5;
long long arr[MAX_N];
int n;

int main()
{
    ios::sync_with_stdio(false);
    cin >> n;
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int value;
        cin >> value;
        if (ans == 0 && value % 7 == 0)
            ans = 1;
        arr[i] = arr[i - 1] + value;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = ans + 1; j + i - 1 <= n; j++) { // j 代表当前的遍历长度
            int end = i + j - 1;
            if ((arr[end] - arr[i - 1]) % 7 == 0)
                ans = j;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 🧠 这段代码的思路
- 先计算前缀和 `arr[i]` 表示前 i 个数的和。
- 然后**双重循环**：外层 i 枚举起点，内层 j 枚举区间长度（从当前已知最优长度+1 开始，想找更长的）。
- 对每个区间 `[i, end]`，用 `(arr[end] - arr[i-1]) % 7 == 0` 判断和是否是 7 的倍数，如果是就更新答案。

### ⏰ 为什么超时？
- 最坏情况下，内层循环几乎要检查所有可能的终点，总检查次数约为 **n²/2**。
- 当 n = 50000 时，计算量 ≈ 12.5 亿次，现代计算机每秒约能执行几千万次操作，这显然会超时。

> 打个比方：这就像你有一长排卡片，你想找最长的一段使得总和是 7 的倍数。笨办法就是**枚举每一段**，一段一段地算总和。50000 张卡片，可能的连续段大约有 12.5 亿个，一个个算当然慢！

---

## 🚀 优化思路 —— 用“余数”做记号

### ✨ 关键发现
如果一段连续数的和是 7 的倍数，那么这段数的**前缀和**有什么关系？

设 `pref[i]` 表示前 i 个数的和（`pref[0] = 0`）。  
区间 `[l, r]` 的和 = `pref[r] - pref[l-1]`。  
如果这个和是 7 的倍数，那么：
```
(pref[r] - pref[l-1]) % 7 == 0
⇒ pref[r] % 7 == pref[l-1] % 7
```
**结论： 两个前缀和对 7 取余相同，它们之间的区间和一定是 7 的倍数。**

### 💡 怎么用这个结论？
- 我们只需要记录**每种余数第一次出现的位置**（前缀和的下标）。
- 然后遍历每个位置 i，看当前前缀和的余数 r 是否出现过：
  - 如果没出现过，就记下这个位置是 r 第一次出现的地方。
  - 如果出现过，那么从第一次出现的位置到当前位置 i 这一段，和一定是 7 的倍数。计算长度 `i - first[r]`，更新答案。

因为只需要一次遍历，时间复杂度 O(n)，空间只需一个长度为 7 的数组。

> 形象理解：给每个前缀和涂上一种“颜色”（7 种颜色之一，由 %7 决定）。如果两个位置颜色相同，它们之间的奶牛组就是 7 的倍数。我们要找的就是**相同颜色的两个最远位置**。

---

## ✅ 优化后的代码

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int first[7]; // 记录每个余数最早出现的位置

int main() {
    ios::sync_with_stdio(false);
    int n;
    cin >> n;

    memset(first, -1, sizeof(first)); // 所有余数初始为 -1
    first[0] = 0; // 余数 0 的第一次出现是前缀和 0 的位置

    long long sum = 0;
    int ans = 0;

    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        sum += x;
        int r = sum % 7;          // 当前前缀和的余数
        if (first[r] == -1) {
            first[r] = i;          // 第一次出现，记下位置
        } else {
            // 出现过，则 [first[r]+1, i] 这段和是 7 的倍数
            ans = max(ans, i - first[r]);
        }
    }

    cout << ans << endl;
    return 0;
}
```

---

## 📊 用样例验证

输入：
```
7
3
5
1
6
2
14
10
```

手动模拟：

| i   | ID  | sum | sum%7 | first[余数] | 长度  | ans |
| --- | --- | --- | ----- | ----------- | ----- | --- |
| 0   |     | 0   | 0     | first[0]=0  |       | 0   |
| 1   | 3   | 3   | 3     | first[3]=1  |       | 0   |
| 2   | 5   | 8   | 1     | first[1]=2  |       | 0   |
| 3   | 1   | 9   | 2     | first[2]=3  |       | 0   |
| 4   | 6   | 15  | 1     | first[1]=2  | 4-2=2 | 2   |
| 5   | 2   | 17  | 3     | first[3]=1  | 5-1=4 | 4   |
| 6   | 14  | 31  | 3     | first[3]=1  | 6-1=5 | 5   |
| 7   | 10  | 41  | 6     | first[6]=7  |       | 5   |

最终 ans = 5，与题目输出一致。区间是 [2, 6] 即 5+1+6+2+14=28 ✅。

---

## 🎯 总结

| 版本       | 时间复杂度 | 空间复杂度 | 优点               | 缺点             |
| ---------- | ---------- | ---------- | ------------------ | ---------------- |
| 原始代码   | O(n²)      | O(n)       | 思路直接，容易理解 | 太慢，n大时超时  |
| 优化后代码 | O(n)       | O(1)       | 飞快，只需一次遍历 | 需要一点数学思维 |

**优化核心**：利用模运算性质，将区间和问题转化为前缀和余数相等问题，从而用“第一次出现位置”代替了双重循环。

> 小提示：负数取模在 C++ 中可能为负，但本题 ID 非负，所以前缀和永远非负，不用担心。

希望这份笔记能帮你彻底搞懂这道题！下次遇到类似“和是某数倍数”的问题，记得用前缀和+模数优化哦～ 🚀