# 1.1 链表
### 1.1.1 动态链表
临时分配节点，使用完成后需要释放节点。优点：空间利用率高；缺点：需要管理空间释放和生成。

### 1.1.2 静态链表
预先分配一段连续的空间存储链表（数组）
两种做法：
- 定义链表结构体数组，和动态链表操作类似
- 使用一维数组，直接在数组上进行链表操作

### 1.1.3 STL list
https://blog.csdn.net/u014779536/article/details/111301635
1. 定义
```CPP
list<A> listname;
list<A> listname(size);
list<A> listname(size,value);
list<A> listname(elselist);
list<A> listname(first, last);
```
2. 添加
```CPP
void push_front(const T& x);	// 头部添加
void push_back(const T& x);		// 尾部添加
```
3. 删除
```CPP
void pop_front();		// 头部删除
void pop_back();		// 尾部删除
```
4. 容器容量
```CPP
size_type size() const;				// 返回元素个数
size_type max_size() const;			// 返回list对象最大允许容量
void resize(size_type n, T x=T());	// 调整list对象的大小
```
5. 迭代器
```CPP
begin()		// 返回指向容器中第一个元素的双向迭代器。
end()		// 返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。
rbegin()	// 返回指向最后一个元素的反向双向迭代器。
rend()		// 返回指向第一个元素所在位置前一个位置的反向双向迭代器。
cbegin()	// 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
cend()		// 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
crbegin()	// 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
crend()		// 	和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。
```
6. 判断是否为空
```CPP
bool empty() const;
```

# 1.2 队列
先进先出
- 链表队列
- 循环队列

优先队列，优先级高的先出队列

### 1.2.1 STL queue
主要操作如下
```CPP
queue<Type> q; // 定义队列
q.push(item); // 把item放入队列
q.front(); // 返回队首元素，但不删除
q.pop(); // 删除队首元素
q.back(); // 返回队尾元素
q.size(); // 返回队中的元素个数
q.empty(); // 判断队列是否为空
```

### 1.2.2 手写循环队列

### 1.2.3 双端队列和单调队列
1. 概念

    队列两边既可以插入元素也可以输出元素

```CPP
deque<Type> dq;     // 定义队列
dq.front();         //返回队头元素
dq.back();          //返回队尾元素
dq.pop_front();     //删除队头元素，不返回值
dq.pop_back();      //删除队尾元素，不返回值
dq.push_front(e);   //在队头插入元素e
dq.push_back(e);    //在队尾插入元素e
```

1. 单调队列和滑动窗口

    保存数组下表，这样可以方便判断当前是否已经离开，洛谷1886

2. 单调队列与最大子序列和问题

* 问题一：不限制子序列长度。在所有可能的子序列中找到一个子序列，该子序列和最大。
  * 使用贪心算法或者动态规划算法

* 问题二：限制子序列长度。给定一个限制长度m，找到一段长度不超过m的连续子序列，使它的子序列和最大。
  * 使用单调子序

### 1.2.4 优先队列
每次让优先级最高的先出队列。不是简单的线性结构，使用堆这种复杂结构实现。


# 1.3 栈

### 1.3.1 STL stack
```CPP
stack<type> s;      // 定义栈
s.push(item);       // 把item放到栈顶
s.top();            // 返回栈顶元素，不删除
s.pop();            // 删除栈顶元素，但不返回
s.size();           // 返回栈中的元素
s.empty();          // 检查栈是否为空
```

### 1.3.2 手写栈

数组模拟

### 1.3.3 单调栈
栈内元素是单调递增或者递减的，当一个元素进去栈的时候，与栈顶元素比较，若栈顶小则入栈，反之一直pop直到为空或者栈顶元素比入栈元素小。

